# -*- coding: utf-8 -*-
"""scartch_se_neuralnet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bBNrZMgjUaFW5WpyPqchUyLJkQxRg6cz
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from keras.datasets import mnist 
from numpy import random

(X_train, y_train), (x_test, y_test) = mnist.load_data()

def sample_image(x):

  plt.rcParams['figure.figsize'] = (9,9) # Make the figures a bit bigger

  for i in range(9):
      plt.subplot(3,3,i+1)
      # num = random.randint(0, len(X_train))
      num=i
      plt.imshow(x[num], cmap='gray', interpolation='none')
      plt.title("Class {}".format(y_train[num]))
      
  plt.tight_layout()

sample_image(X_train)

x_train=np.zeros(shape=(60000,784))
i=0
while i<len(X_train):
  x_train[i]=X_train[i].reshape(-1)
  i=i+1

# a=x_train.reshape(-1)       # random code cell to check data is correctly store or not
# sample_image(a.reshape(60000,28,28))
# a.dtype
len(x_train[59999])

"""**data :
 x_train and y_train**
"""

# layer1=np.zeros(20)
# layer2=np.zeros(20)
# output_layer=np.zeros(20)

def add_column_of_1(arr):
  new_column = np.array([1], ndmin=1)
  return np.concatenate((new_column, arr))

def sigmoid(arr):
  return (1/(1+np.exp(-arr)))

def z_layer(wb,arr):
  arr=add_column_of_1(arr)
  return (np.dot(wb,arr))

def calu(wb,arr):
  return sigmoid(z_layer(wb,arr))

def prediction(data,wb1,wb2,wb3):
  layer1=calu(wb1,data)
  layer2=calu(wb2,layer1)
  return calu(wb3,layer2)

def cost(pred,output):
  i=0
  cost=0
  while i<10:
    if(output!=i):
      cost=cost+pred[i]*pred[i]
    else:
      cost=cost+(pred[i]-1)*(pred[i]-1)
    i=i+1
  return cost

# print(prediction(x_train[0],wb1,wb2,wb3),y_train[0])

# cost(prediction(x_train[0],wb1,wb2,wb3),y_train[0],wb1,wb2,wb3)

"""len of twb=16330    
wb1=785*20=15,700   
wb2=21*20=420 (16,120)    
wb3=21*10=210 (16,330)
"""

def d_oc_l3(layer3,cost):
  d_o_c_l3=np.zeros(10)
  i=0
  while i<10:
   if cost==i:
     d_o_c_l3[i]=2*(layer3[i]-1)
   else:
     d_o_c_l3[i]=2*layer3[i]
   i=i+1
  return d_o_c_l3

def deff_of_sigmoid(z):
  a=np.exp(-z)
  return np.divide(a,np.multiply((1+a),(1+a)))

def grad_wb(layer,d_o_s_l,d_o_c_l,m,n):
  i=0
  j=0
  grad_wb=np.ones(shape=(m,n))
  while i<m:
    j=0
    while j<n:
      if j==0:
        grad_wb[i,j]=d_o_s_l[i]*d_o_c_l[i]
      else:
        grad_wb[i,j]=layer[j-1]*d_o_s_l[i]*d_o_c_l[i]
      j=j+1
    i=i+1
  return grad_wb

def doc(wb,d_o_s,d_o_c_l,m,n):
  i=0
  j=0
  d_o_c=np.zeros(n)
  while i<n:
    j=0
    while j<m:
      d_o_c[i] += wb[j,i+1]*d_o_s[j]*d_o_c_l[j]
      j=j+1
    i=i+1

  return d_o_c

def backprop(input,output,wb1,wb2,wb3):
  grad_wb1=np.zeros(shape=(20,785))
  grad_wb2=np.zeros(shape=(20,21))
  grad_wb3=np.ones(shape=(10,21))
  z_layer1=z_layer(wb1,input)
  layer1=sigmoid(z_layer1)
  z_layer2=z_layer(wb2,layer1)
  layer2=sigmoid(z_layer2)
  z_layer3=z_layer(wb3,layer2)
  layer3=sigmoid(z_layer3)
  d_o_c_l3=d_oc_l3(layer3,output)
  d_o_s_l3=deff_of_sigmoid(z_layer3)
  d_o_s_l2=deff_of_sigmoid(z_layer2)
  d_o_s_l1=deff_of_sigmoid(z_layer1)
  grad_wb3=grad_wb(layer2,d_o_s_l3,d_o_c_l3,10,21)
  d_o_c_l2=doc(wb3,d_o_s_l3,d_o_c_l3,10,20)
  grad_wb2=grad_wb(layer1,d_o_s_l2,d_o_c_l2,20,21)
  d_o_c_l1=doc(wb2,d_o_s_l2,d_o_c_l2,20,20)
  grad_wb1=grad_wb(input,d_o_s_l1,d_o_c_l1,20,785)
  cst=cost(layer3,output)

  return grad_wb1,grad_wb2,grad_wb3,cst

c_f=np.zeros(1000)
wb1=np.zeros(shape=(20,785))
wb2=np.zeros(shape=(20,21))
wb3=np.ones(shape=(10,21))
lr=0.001
print(backprop(x_train[0],y_train[0],wb1,wb2,wb3))

for x in range(1000):
  grad_wb1=np.zeros(shape=(20,785))
  grad_wb2=np.zeros(shape=(20,21))
  grad_wb3=np.ones(shape=(10,21))
  cost_f=0
  for y in range(100):
    i=random.randint(60000)
    a,b,c,cst = backprop(x_train[i],y_train[i],wb1,wb2,wb3)
    grad_wb1 = np.add(a,grad_wb1)
    grad_wb2 = np.add(b,grad_wb2)
    grad_wb3 = np.add(c,grad_wb3)
    cost_f += cst
  grad_wb1 = (grad_wb1/100)
  grad_wb2 = (grad_wb2/100)
  grad_wb3 = (grad_wb3/100)
  cost_f=(cost_f)/100
  c_f[x]=cost_f
  wb1=np.subtract(wb1,lr*grad_wb1)
  wb2=np.subtract(wb2,lr*grad_wb2)
  wb3=np.subtract(wb3,lr*grad_wb3)
  print(x,cost_f)

plt.plot(cf)

print(wb1[0])